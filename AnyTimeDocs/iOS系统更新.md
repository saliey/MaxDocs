


# 总结

1. 系统下载要更新的系统文件，系统更新包括有：系统应用，基础库，内核，系统库，其他组件
2. 系统更新进程将系统根路径挂载，挂载为可写权限，然后将下载的文件替换，新文件替换旧文件
3. 替换完成后，将系统文件挂为只读，取消挂载，重启则就是更新

4. 需要通过挂载实现操作系统对文件系统的控制，所以要更改系统内的固件信息，则必须将特定区域挂载为可写权限。一般只有特定的进程或系统级权限的进程才能进行挂载。
挂载的目的就是进程访问文件系统，提升对文件系统的操作能力。

5. 主要的更新步骤：
下载解压系统文件 -> 备份数据 -> 替换系统文件 -> 更新配置 -> 验证更新 -> 取消挂载 -> 设备重启

6. 系统更新时预留的活跃进程：
更新进程，文件系统的驱动程序，日志和监控，基本硬件驱动，网络通信进程，安全和加密服务

7. 挂载命令
系统更新进程 com.apple.os.update 的更新命令：
" mount -t apfs -o ro /dev/disk0s1 / "
这句的意思是将根路径挂载到 '/dev/disk0s1' 卷，这样就可以对整个文件系统做操作了。

8. 随机串的生成：
在挂载完成后发现根路径的 “struct statfs”结构的 “f_mntfromname” 参数为 "com.apple.os.update-xxxx@/dev/disk0s2"。
挂载后文件系统结构体的 f_mntfromname 所对应的 "xxxx" 子字符串是随机生成的，是用于在系统重启时跟踪挂载点。
这个值是根据时间和 com.apple.os.update 进程 ID 和一个随机值生成的，所以很随机。
系统使用 `xxxx` 字符串来跟踪系统重启时的挂载点。 这可确保系统根路径始终挂载到同一卷，即使重新格式化或更换卷也是如此。

9. 系统为什么要跟踪挂载点：
为了提高系统的可靠性、可恢复性、故障排查能力，也就是系统恢复时需要用到的，比如预升级后再恢复。
系统启动时需要挂载根路径才能启动。


# 1. 更新进程

iOS中的com.apple.os.update相关程序是一个系统更新框架，用于在iOS设备上下载和安装系统更新。 它是 iOS 操作系统的一部分，负责管理系统更新的安装。

当有新的系统更新可用时，com.apple.os.update 框架会将更新下载到设备的存储空间。 下载更新后，框架将验证更新的签名，然后将其安装到设备上。

com.apple.os.update 框架还管理 iOS 设备上安全更新的安装。 通常会发布安全更新以修复 iOS 操作系统中的安全漏洞。 只要设备连接到互联网，com.apple.os.update 框架就会自动下载并安装安全更新。

com.apple.os.update 框架是 iOS 操作系统的重要组成部分，负责通过最新的安全更新和错误修复使 iOS 设备保持最新状态。

以下是 com.apple.os.update 相关程序为系统更新所做的一些事情：

* 从 Apple 服务器下载系统更新。
* 验证系统更新的签名以确保它们来自 Apple。
* 在 iOS 设备上安装系统更新。
* 管理 iOS 设备上安全更新的安装。
* 向用户提供有关可用系统更新的通知。

com.apple.os.update 相关程序是 iOS 操作系统的重要组成部分，负责通过最新的安全更新和错误修复使 iOS 设备保持最新状态。 使用最新的系统更新使您的 iOS 设备保持最新状态非常重要，以确保它是安全的并且您能够使用所有最新功能。

# 2. 如何挂载 

com.apple.os.update 进程使用 `mount` 命令挂载系统根路径。 `mount` 命令用于将文件系统附加到挂载点。 对于 com.apple.os.update 进程，挂载点是 iOS 设备的根目录。

挂载时对应的路径为`/`。 这是 iOS 设备根目录的路径。 根目录是文件系统的顶级目录。 它包含文件系统上的所有其他目录和文件。

当 com.apple.os.update 进程挂载系统根路径时，它能够访问文件系统上的所有文件和目录。 这允许进程安装系统更新。

以下是 com.apple.os.update 进程如何挂载系统根路径的示例：

```
mount -t apfs -o ro /dev/disk0s1 /
```

此命令将 `/dev/disk0s1` 上的文件系统挂载到挂载点 `/`。 `-t` 选项指定文件系统类型，在本例中为 APFS。 `-o` 选项指定挂载选项，在本例中为 `ro`，这意味着文件系统以只读方式挂载。

一旦安装了系统根路径，com.apple.os.update 进程就可以安装系统更新。 该过程将首先验证更新的签名，以确保它来自 Apple。 验证签名后，该过程将在设备上安装更新。

安装系统更新可能需要一些时间，具体取决于更新的大小。 安装更新后，设备将重新启动。 必须重新启动才能使对文件系统的更改生效。

设备重启后，系统更新完成。 该设备将与最新的安全更新和错误修复保持同步。

# 3. 挂载路径的选择

com.apple.os.update 进程挂载到根路径时默认选择挂载的目标磁盘路径，基于以下条件：

* 第一个可用的 APFS 卷。
* 第一个可用的 HFS+ 卷。
* 未加密的第一个可用卷。

如果没有未加密的 APFS 或 HFS+ 卷，那么 com.apple.os.update 进程将无法挂载系统根路径。

com.apple.os.update进程默认选择挂载的目标磁盘路径，以确保系统更新能够成功安装。 如果进程选择不同的磁盘路径，则更新可能无法正确安装。

以下是 com.apple.os.update 进程用来选择挂载目标磁盘路径的标准的解释：

* **APFS：** APFS 是 iOS 设备的默认文件系统。 它是一种现代文件系统，与 HFS+ 相比具有许多优势，例如更好的性能和对快照的支持。
* **HFS+：** HFS+ 是 iOS 设备的旧文件系统。 iOS 仍然支持它，但它不是默认的文件系统。
* **加密：** com.apple.os.update 进程不支持加密卷。 这是因为进程需要能够访问文件系统上的所有文件才能安装更新。

如果您使用的 iOS 设备有多个卷，则可以使用 `mount` 命令更改挂载的目标磁盘路径。 例如，要将系统根路径挂载到第二个 APFS 卷，您可以使用以下命令：

```
mount -t apfs -o ro /dev/disk0s2 /
```

此命令将 `/dev/disk0s2` 上的文件系统挂载到挂载点 `/`。 `-t` 选项指定文件系统类型，在本例中为 APFS。 `-o` 选项指定挂载选项，在本例中为 `ro`，这意味着文件系统以只读方式挂载。

更改安装的目标磁盘路径后，您需要重新启动 iOS 设备才能使更改生效。

## 系统卷的选择

默认情况下，com.apple.os.update 进程会选择 `/dev/` 路径下的第一个可用的 APFS 卷。 com.apple.os.update 进程的默认选项是：

* `-t apfs`：指定文件系统类型为 APFS。
* `-o ro`：以只读方式挂载文件系统。

`-t` 选项指定文件系统类型，在本例中为 APFS。 `-o` 选项指定挂载选项，在本例中为 `ro`，这意味着文件系统以只读方式挂载。

com.apple.os.update 进程只会安装第一个可用的 APFS 卷。 如果没有可用的 APFS 卷，则进程将无法挂载系统根路径。

以下是 com.apple.os.update 进程可以选择的一些 APFS 宗卷：

* `/dev/disk0s1`：设备上的第一个 APFS 卷。
* `/dev/disk0s2`：设备上的第二个 APFS 卷。
* `/dev/disk0s3`：设备上的第三个 APFS 卷。

com.apple.os.update 进程将选择第一个未加密的可用 APFS 卷。 如果没有未加密的 APFS 卷，则进程将无法挂载系统根路径。

如果您使用的 iOS 设备具有多个 APFS 卷，则可以使用 `mount` 命令更改挂载的目标磁盘路径。 例如，要将系统根路径挂载到第二个 APFS 卷，您可以使用以下命令：

```
mount -t apfs -o ro /dev/disk0s2 /
```

此命令将 `/dev/disk0s2` 上的文件系统挂载到挂载点 `/`。 `-t` 选项指定文件系统类型，在本例中为 APFS。 `-o` 选项指定挂载选项，在本例中为 `ro`，这意味着文件系统以只读方式挂载。

更改安装的目标磁盘路径后，您需要重新启动 iOS 设备才能使更改生效。

## mount 命令的解释

是的，当命令 `mount -t apfs -o ro /dev/disk0s2 /` 执行挂载时，它将 `/` 根路径挂载到 `/dev/disk0s2` 卷。

该命令的具体含义是将`/dev/disk0s2`上的文件系统挂载到挂载点`/`。 `-t` 选项指定文件系统类型，在本例中为 APFS。 `-o` 选项指定挂载选项，在本例中为 `ro`，这意味着文件系统以只读方式挂载。

挂载后，`/` 根路径将与`/dev/disk0s2` 卷具有相同的操作权限。 这意味着如果 `/dev/disk0s2` 卷以只读方式挂载，则 `/` 根路径也将以只读方式挂载。

这是命令的细分：

* `mount`：`mount` 命令用于将文件系统附加到挂载点。
* `-t apfs`：指定文件系统类型为 APFS。
* `-o ro`：以只读方式挂载文件系统。
* `/dev/disk0s2`：您要挂载的 APFS 卷的路径。
* `/`：挂载点。 这是文件系统将挂载到的目录。

## 挂载根路径后，文件系统的结构体的 f_mntfromname

根目录“/”的“struct statfs”结构中的“f_mntfromname”参数将是挂载的 APFS 卷的路径。 在这种情况下，路径将为“/dev/disk0s2”。

`struct statfs` 结构用于存储有关文件系统的信息。 `f_mntfromname` 参数存储文件系统挂载点的路径。

在命令 `mount -t apfs -o ro /dev/disk0s2 /` 的情况下，根目录 `/` 被挂载到 APFS 卷 `/dev/disk0s2`。 这意味着根目录“/”的“struct statfs”结构中的“f_mntfromname”参数将是“/dev/disk0s2”。

## 挂载后的随机值产生

`f_mntfromname` 参数中间的 `xxxx` 字符串是挂载点的唯一标识符。 此标识符由 com.apple.os.update 进程生成，用于在系统重新启动时跟踪挂载点。

标识符是使用随机数生成器生成的。 随机数生成器以当前时间和 com.apple.os.update 进程的进程 ID 为种子。 这确保标识符对于每个挂载点都是唯一的。

标识符存储在“struct statfs”结构的“f_mntfromname”参数中。 这允许系统在系统重新启动时跟踪挂载点。

当 com.apple.os.update 进程挂载系统根路径时，它会将 `f_mntfromname` 参数设置为 `com.apple.os.update-xxxx@/dev/disk0s2`。 `xxxx` 字符串是挂载点的唯一标识符。

系统使用 `xxxx` 字符串来跟踪系统重启时的挂载点。 这可确保系统根路径始终挂载到同一卷，即使重新格式化或更换卷也是如此。

以下是对 `xxxx` 字符串的解释：

* `com.apple.os.update`：这是安装卷的系统进程的名称。
* `xxxx`：这是挂载点的唯一标识符。
* `@/dev/disk0s2`：这是安装的卷的路径。

## 为什么重新启动时需要跟踪挂载点？

由于一些原因，iOS 系统在重新启动时会跟踪挂载点。

* **确保系统根路径挂载正确。** iOS系统重启时，需要挂载系统根路径才能开机。 如果未跟踪安装点，则系统根路径可能会安装到错误的卷。 这可能导致系统无法启动或运行不稳定。
* **让系统从失败的更新中恢复。**如果系统更新失败，那么iOS系统可能需要恢复到之前的系统版本。 为此，系统需要知道系统先前版本的挂载点。 如果没有跟踪安装点，则系统可能无法恢复到以前的系统版本。
* **让系统排查问题。**如果iOS系统遇到问题，那么工程师可能需要知道系统根路径的挂载点。 此信息可以帮助工程师诊断问题并解决问题。

跟踪挂载点是一项相对简单的任务，但它对于确保 iOS 系统正确启动以及可以从失败的更新中恢复非常有帮助。

以下是在 iOS 系统重启时跟踪挂载点的一些好处：

* **提高可靠性：**如果安装点被跟踪，系统将不太可能无法启动或行为不稳定。
* **改进的可恢复性：**如果跟踪挂载点，系统更有可能从失败的更新中恢复。
* **增强的故障排除：** 如果跟踪安装点，工程师更有可能诊断和修复问题。

总的来说，在 iOS 系统重启时跟踪挂载点是一个很好的做法，有助于提高系统的可靠性、可恢复性和故障排除能力。

# 4. 'struct statfs' 结构体

在 MacOS 或其他基于 BSD 的系统中，`struct statfs` 的定义和 Linux 中有所不同。你可以在 `/usr/include/sys/mount.h` 文件中找到该定义。以下是 MacOS 下 `struct statfs` 的定义：

```c
struct statfs {
    short   f_otype;       /* OLD: type of filesystem (see below) */
    short   f_oflags;      /* OLD: flags (see below) */
    long    f_bsize;       /* fundamental file system block size */
    long    f_iosize;      /* optimal transfer block size */
    long    f_blocks;      /* total data blocks in file system, */
    long    f_bfree;       /* free blocks in fs */
    long    f_bavail;      /* free blocks avail to non-su */
    long    f_files;       /* total file nodes in file system */
    long    f_ffree;       /* free file nodes in fs */
    fsid_t  f_fsid;        /* file system id */
    uid_t   f_owner;       /* user that mounted the filesystem */
    short   f_reserved1;   /* spare for later */
    short   f_type;        /* type of filesystem */
    long    f_flags;       /* copy of mount flags */
    long    f_reserved2[2];/* reserved for future use */
    char    f_fstypename[MFSNAMELEN];  /* fs type name */
    char    f_mntonname[MNAMELEN];     /* directory on which mounted */
    char    f_mntfromname[MNAMELEN];   /* mounted filesystem */
    char    f_reserved3;   /* reserved for future use */
    long    f_reserved4[4];/* reserved for future use */
};
```

这个结构体的各元素含义如下：

1. **f_otype:** 文件系统类型的旧版本。

2. **f_oflags:** 文件系统标志的旧版本。

3. **f_bsize:** 基本文件系统块的大小。

4. **f_iosize:** 最佳传输块的大小。

5. **f_blocks:** 文件系统中的总数据块数。

6. **f_bfree:** 在文件系统中可用的块数。

7. **f_bavail:** 对于非超级用户，文件系统中可用的块数。

8. **f_files:** 文件系统中的总文件节点数。

9. **f_ffree:** 文件系统中可用的文件节点数。

10. **f_fsid:** 文件系统标识符。

11. **f_owner:** 挂载文件系统的用户。

12. **f_reserved1:** 留给以后使用的备用字段。

13. **f_type:** 文件系统类型。

14. **f_flags:** 文件系统的挂载标志的副本。

15. **f_reserved2[2]:** 留给以后使用的备用字段。

16. **f_fstypename[MFSNAMELEN]:** 文件系统类型名称。

17. **f_mntonname[MNAMELEN]:** 文件系统挂载的目录。

18. **f_mntfromname[MNAMELEN]:** 被挂载的文件系统。

19. **f_reserved3:** 留给以后使用的备用字段。

20. **f_reserved4[4]:** 留给以后使用的备用字段。

和 Linux 类似，这个结构体通常也是 `statfs()` 函数的输出，用来返回一个特定挂载点的文件系统状态。


# 4. 系统更新原理

#### You:
iOS 系统更新的技术原理是什么？系统更新的技术逻辑是什么？

#### ChatGPT:
iOS 系统更新的技术原理和逻辑涉及多个方面，包括但不限于以下几个方面：

1. **版本检测和通知**：iOS 设备会定期检查更新。当 Apple 发布新版本的 iOS 时，设备会收到通知告诉用户有新版本可用。

2. **下载更新包**：用户选择更新后，设备会从 Apple 的服务器下载更新包。这个更新包包含了新版本的系统文件和代码。

3. **数据备份**：在开始更新之前，iOS 系统通常会提示用户备份数据。这是为了防止在更新过程中出现问题，从而导致数据丢失。

4. **安装更新**：下载完成后，设备会进入更新模式。在这个阶段，旧的系统文件会被新的文件替换。这个过程通常会涉及到文件系统的变更，以及底层操作系统代码的更新。

5. **优化和重建缓存**：更新安装完成后，iOS 会对新系统进行优化。这包括重建应用缓存，以及优化新系统的性能。在这个阶段，用户可能会注意到设备的启动时间较长。

6. **数据恢复**：如果在更新过程中出现问题，iOS 会尝试使用之前备份的数据来恢复设备。

7. **验证和报告**：完成更新后，系统会向 Apple 发送一个报告，确认更新的状态。这有助于 Apple 收集关于更新过程的数据，以改进未来的更新。

8. **应用兼容性检查**：新版本的 iOS 可能会包含 API 变更或新的安全特性。因此，应用程序可能需要更新以确保与新版本的 iOS 兼容。用户可能需要从 App Store 下载应用的更新。

需要注意的是，iOS 系统更新是一个复杂的过程，涉及到底层的操作系统代码、文件系统、网络通信和安全机制。在更新过程中，系统会采取一系列步骤来确保数据的安全性和系统的稳定性。


#### You:
第四步说的旧系统文件被替换为新的文件的技术逻辑是什么？是否有挂载的操作？

#### ChatGPT:
在iOS系统的更新过程中，第四步涉及到将新的系统文件替换旧的文件。这一过程的技术逻辑相当复杂，通常包括以下步骤：

1. **验证更新包**：在安装更新之前，iOS会验证更新包的完整性和签名。这是为了确保更新包是来自Apple并且没有被篡改。

2. **进入恢复模式**：为了安全地进行系统更新，iOS设备通常会进入一种特殊的恢复模式。在这种模式下，系统可以在较低的层次上访问文件系统。

3. **挂载文件系统**：确实，这个过程涉及到挂载的操作。iOS系统会将文件系统挂载为可写，以便可以修改系统文件。通常，iOS的文件系统是只读的，以增加安全性。在更新过程中，必须临时更改这一设置，以便替换系统文件。

4. **替换系统文件**：系统将开始替换旧的系统文件。这包括内核、系统库、应用程序和其他组件。通常，这是通过将新文件复制到适当的位置来完成的。

5. **更新引导加载程序**：在某些情况下，系统更新可能还包括更新设备的引导加载程序。这是一个关键的组件，用于在设备启动时加载操作系统。

6. **卸载文件系统**：一旦所有的系统文件都被替换，iOS会将文件系统重新设置为只读，并卸载它。这是为了恢复正常的安全设置。

7. **重新启动**：最后，设备将重新启动。在重新启动时，新的系统文件将被加载，并且设备将以更新后的iOS版本运行。

这个过程需要精确的控制和协调，因为在替换系统文件时出现的任何错误都可能导致系统不稳定或无法启动。因此，iOS在更新过程中采用了一系列的安全措施，以最大限度地减少出现问题的风险。


#### You:
挂载是什么意思？为什么系统更新需要挂载？挂载的技术底层逻辑是什么？

#### ChatGPT:
"挂载"这个词在计算机科学中通常用于描述操作系统访问文件系统的过程。文件系统通常存储在硬盘驱动器、固态硬盘、USB驱动器、网络服务器或其他存储设备上。当这些设备连接到计算机时，操作系统需要以一种可以理解和操作的方式访问存储在设备上的文件。这个过程就是挂载。

挂载的过程可以理解为操作系统创建一个访问路径（或称为挂载点），通过这个路径，操作系统和应用程序可以访问到存储设备上的文件和目录，就好像这些文件和目录是本地存储的一样。在Unix和类Unix系统（如Linux和macOS）中，所有的设备和文件系统都通过这种方式连接到文件系统的一棵树中。在Windows系统中，每个设备和文件系统通常会被分配一个驱动器字母（如C:，D:等）。

在iOS系统更新中，挂载的操作是必须的，因为系统需要能够写入到文件系统，替换旧的系统文件。通常，为了安全起见，iOS的文件系统是只读的，这可以防止恶意软件修改系统文件。然而，在更新过程中，系统需要临时的写入权限，以便可以安装新的版本。因此，iOS会先将文件系统挂载为可写，进行更新操作，然后再将其设置回只读。

技术底层来看，挂载过程涉及到以下步骤：

1. **设备识别**：操作系统首先需要识别出设备和它的文件系统类型。这是通过读取设备的元数据和系统的设备驱动程序来完成的。

2. **加载文件系统驱动程序**：操作系统需要加载正确的文件系统驱动程序，以便可以正确地读取和写入文件系统。驱动程序是操作系统用来与硬件设备交互的一种软件。

3. **创建挂载点**：操作系统创建一个挂载点，这是一个在系统文件树中的位置，通过这个位置，可以访问到文件系统。

4. **连接设备**：最后，操作系统将设备连接到挂载点。这样，就可以通过挂载点来访问和操作设备上的文件了。

这个过程需要操作系统的核心组件（称为内核）和设备驱动程序的密切协作。如果有任何步骤出错，都可能导致设备无法正确地挂载，从而无法访问文件系统。


#### You:
在系统更新时是谁挂载谁，挂载完之后怎样操作的更新逻辑？

#### ChatGPT:
在iOS系统更新时，是操作系统（iOS）挂载自己的根文件系统。具体来说，通常是iOS的更新程序或恢复模式负责这个过程。挂载的目的是使根文件系统变为可写，以便能够替换旧的系统文件。通常，iOS的根文件系统是只读的，以增加安全性。在更新过程中，系统需要临时更改这一设置以替换系统文件。

挂载根文件系统为可写状态后，系统更新的逻辑通常包括以下步骤：

1. **解压和准备更新文件**：系统会解压收到的更新包，并准备将其写入到文件系统。这个更新包通常包含了新版本的内核、系统库、应用程序和其他组件。

2. **备份和保护用户数据**：系统会尽量保护用户数据不受影响。这可能包括创建系统设置和用户数据的备份。

3. **替换系统文件**：更新程序开始替换旧的系统文件。这包括覆盖现有的文件和添加新的文件。这一步是整个更新过程中最关键的部分，因为它实际上在更改操作系统的核心部分。

4. **更新配置和设置**：系统可能需要更新某些配置文件和系统设置，以适应新版本的变化。

5. **验证更新**：系统会验证更新的完整性和一致性，确保所有的文件都已正确地安装。

6. **卸载文件系统**：一旦更新完成，系统会将根文件系统重新设置为只读，并卸载它。这样可以恢复正常的安全设置。

7. **重启设备**：最后，设备会重新启动。在重新启动时，新的系统文件会被加载，设备将开始运行更新后的iOS版本。

8. **后处理和优化**：设备在启动后可能会进行一些后处理步骤，如重建缓存、优化性能等。

需要注意的是，这个过程需要精确的控制和协调，因为在替换系统文件时出现的任何错误都可能导致系统不稳定或无法启动。因此，iOS在更新过程中采用了一系列的安全措施，以最大限度地减少出现问题的风险。


#### You:
挂载之后怎样恢复到非挂载的状态？什么样的程序具有挂载的权限？挂载后系统的空间是否有变化？

#### ChatGPT:
在挂载之后，操作系统需要执行一个过程来断开与文件系统的连接，这个过程通常被称为“卸载”或“解除挂载”。在iOS系统更新中，一旦新的系统文件被成功写入，系统会解除挂载根文件系统，并可能将其重新设置为只读模式以增加安全性。以下是解除挂载过程的步骤：

1. **关闭文件和应用程序**：在解除挂载之前，任何正在使用该文件系统的文件和应用程序都需要被关闭。

2. **同步数据**：操作系统会将所有挂起的写操作同步到磁盘。这是为了确保所有数据都已被正确地保存。

3. **解除挂载命令**：操作系统执行一个特定的命令或系统调用来解除挂载文件系统。这会断开文件系统与操作系统之间的连接。

4. **恢复安全设置**：如果文件系统是为了特定操作（如系统更新）而被设置为可写，那么在解除挂载后，操作系统可能会将其重新设置为只读模式。

通常，只有具有管理员或根用户权限的程序才能挂载和解除挂载文件系统。在iOS上，这通常是受到严格控制的，只有系统组件（如更新程序）能够执行这些操作。普通应用程序和用户没有权限挂载或解除挂载文件系统。

至于系统空间的变化，挂载本身不会改变存储空间的使用。挂载只是建立了一个访问路径，允许操作系统访问文件系统。然而，如果在挂载状态下进行了写操作（例如，在系统更新中替换文件），那么存储空间的使用可能会发生变化。这取决于写入的数据量以及是否有文件被删除或替换。在系统更新的情况下，通常会有一些空间的变化，因为新的系统文件可能比旧的文件大或小。


#### You:
系统更新时，根路径被挂载，那么所谓的更新逻辑是系统更新进程在挂载路径下更换系统镜像文件，对吗？那么在系统更新的那一刻，系统还有哪些进程是活跃的？

#### ChatGPT:
在iOS系统更新时，是的，根文件系统被挂载为可写，以便更新程序可以替换旧的系统文件。不过，通常不是简单地更换一个完整的系统镜像文件，而是更换和更新多个系统组件，包括内核、系统库、应用程序和其他文件。系统更新程序会根据更新包的内容，逐个替换或更新这些组件。

在系统更新过程中，通常有一个精简的环境在运行，以保持基本的系统功能。以下是在系统更新期间可能活跃的一些进程：

1. **系统更新进程**：这是负责管理更新的核心进程。它负责解压更新包，替换系统文件，以及执行与更新相关的其他任务。

2. **文件系统驱动程序**：为了读取和写入文件系统，文件系统驱动程序必须处于活动状态。

3. **日志和监控进程**：通常会有一些进程负责记录更新过程中的事件和可能的错误，以便于后续的分析和故障排除。

4. **基本硬件驱动程序**：为了与设备的硬件进行通信（如存储设备、显示屏、电源管理），必须运行相应的硬件驱动程序。

5. **网络通信进程**：如果更新是通过网络进行的，那么网络通信进程需要保持活跃以维持与外部服务器的连接。

6. **安全和加密服务**：用于验证更新包的完整性和安全性的安全和加密服务可能也在运行。

请注意，由于安全和可靠性的考虑，系统更新通常在一个受控和限制的环境中进行，以减少错误和干扰的风险。因此，不必要的后台进程和应用程序通常会在更新过程开始之前被关闭。此外，不同的操作系统和不同版本的更新程序可能具有不同的行为和活动进程。



